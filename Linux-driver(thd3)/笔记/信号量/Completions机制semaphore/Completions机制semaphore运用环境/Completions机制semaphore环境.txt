内核编程的一个普通模式包括在当前线程之外初始化某个动作, 接着等待这个动作结束.
这个动作可能是创建一个新内核线程或者用户空间进程, 对一个存在着的进程的请求, 或
者一些基于硬件的动作. 在这些情况中, 很有诱惑去使用一个旗标来同步 2 个任务, 使
用这样的代码:
	struct semaphore sem;
	init_MUTEX_LOCKED(&sem);
	start_external_task(&sem);
	down(&sem);
在它的工作完成时.外部任务可以接着调用 up(??sem),

事实证明, 这种情况旗标不是最好的工具. 正常使用中, 试图加锁一个旗标的代码发现旗
标几乎在所有时间都可用; 如果对旗标有很多竞争, 性能会受损并且加锁方案需要重新审
视. 因此旗标已经对"可用"情况做了很多的优化. 当用上面展示的方法来通知任务完成,
然而, 调用 down 的线程将几乎是一直不得不等待; 因此性能将受损. 旗标还可能易于处
于一个( 困难的 ) 竞争情况, 如果它们表明为自动变量以这种方式使用时. 在一些情况
中, 旗标可能在调用 up 的进程用完它之前消失.
这些问题引起了在 2.4.7 内核中增加了 "completion" 接口. completion 是任务使用的
一个轻量级机制: 允许一个线程告诉另一个线程工作已经完成.