多年使用锁的经验 -- 早于 Linux 的经验 -- 已经表明加锁可能是非常难于正确的. 管
理并发是一个固有的技巧性的事情, 有很多出错的方式. 在这一节, 我们快速看一下可能
出错的东西.

1）模糊的规则
如同上面已经说过的, 一个正确的加锁机制需要清晰和明确的规则. 当你创建一个可以被
并发存取的资源时, 你应当定义哪个锁将控制存取. 加锁应当真正在开始处进行; 事后更
改会是难的事情. 开始时花费的时间常常在调试时获得回报.

当你编写你的代码, 你会毫无疑问遇到几个函数需要存取通过一个特定锁保护的结构. 在
此, 你必须小心: 如果一个函数需要一个锁并且接着调用另一个函数也试图请求这个锁,
你的代码死锁. 不论旗标还是自旋锁都不允许一个持锁者第 2 次请求锁; 如果你试图这
样做, 事情就简单地玩完了.

为使的加锁正确工作, 你不得不编写一些函数, 假定它们的调用者已经获取了相关的锁.
常常地, 只有你的内部的, 静态函数能够这样编写; 从外部调用的函数必须明确处理加锁.
当你编写内部函数对加锁做了假设, 方便自己(和其他使用你的代码的人)并且明确记录这
些假设. 在几个月后可能很难回来并记起是否你需要持有一个锁来调用一个特殊函数.

