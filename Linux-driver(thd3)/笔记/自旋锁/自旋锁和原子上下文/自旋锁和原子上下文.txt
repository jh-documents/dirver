想象一会儿你的驱动请求一个自旋锁并且在它的临界区里做它的事情. 在中间某处, 你的
驱动失去了处理器. 或许它已调用了一个函数( copy_from_user, 假设) 使进程进入睡眠.
或者, 也许, 内核抢占发威, 一个更高优先级的进程将你的代码推到一边. 你的代码现在
持有一个锁, 在可见的将来的任何时间都不会释放这个锁. 如果某个别的线程想获得同一个
锁, 它会, 在最好的情况下, 等待( 在处理器中自旋 )很长时间. 最坏的情况, 系统可能
完全死锁.

大部分读者会同意这个场景最好是避免. 因此, 应用到自旋锁的核心规则是任何代码必须,
在持有自旋锁时, 是原子性的. 它不能睡眠; 事实上, 它不能因为任何原因放弃处理器,
除了服务中断(并且有时即便此时也不行)

内核抢占的情况由自旋锁代码自己处理. 内核代码持有一个自旋锁的任何时间, 抢占在相
关处理器上被禁止. 即便单处理器系统必须以这种方式禁止抢占以避免竞争情况. 这就是
为什么需要正确的加锁, 即便你从不期望你的代码在多处理器机器上运行.

在持有一个锁时避免睡眠是更加困难; 很多内核函数可能睡眠, 并且这个行为不是都被明
确记录了. 拷贝数据到用户空间到或从用户空间拷贝数据是一个明显的例子: 请求的用户
空间页可能需要在拷贝进行前从磁盘上换入, 这个操作显然需要一个睡眠. 必须分配内存
的任何操作都可能睡眠. kmalloc 能够决定放弃处理器, 并且等待更多内存可用除非它被
明确告知不这样做.

睡眠可能发生在令人惊讶的地方; 编写会在自旋锁下执行的代码需要注意你调用的每个函
数.

这有另一个场景: 你的驱动在执行并且已经获取了一个锁来控制对它的设备的存取. 当持
有这个锁时, 设备发出一个中断, 使得你的中断处理运行. 中断处理, 在存取设备之前,
必须获得锁. 在一个中断处理中获取一个自旋锁是一个要做的合法的事情; 这是自旋锁操
作不能睡眠的其中一个理由. 但是如果中断处理和起初获得锁的代码在同一个处理器上会
发生什么? 
当中断处理在自旋, 非中断代码不能运行来释放锁. 这个处理器将永远自旋.

避免这个陷阱需要在持有自旋锁时禁止中断( 只在本地 CPU ). 有各种自旋锁函数会为你
禁止中断.

关于自旋锁使用的最后一个重要规则是自旋锁必须一直是尽可能短时间的持有. 你持有一
个锁越长, 另一个进程可能不得不自旋等待你释放它的时间越长, 它不得不完全自旋的机
会越大. 长时间持有锁也阻止了当前处理器调度, 意味着高优先级进程 -- 真正应当能获
得 CPU 的 -- 可能不得不等待. 

内核开发者尽了很大努力来减少内核反应时间( 一个进程可能不得不等待调度的时间 )在 
2.5 开发系列. 一个写很差的驱动会摧毁所有的进程, 仅仅通过持有一个锁太长时间. 为
避免产生这类问题, 重视使你的锁持有时间短.

