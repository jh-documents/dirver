在有大量锁的系统中(并且内核在成为这样一个系统), 一次需要持有多于一个锁, 对代码
是不寻常的. 如果某类计算必须使用 2 个不同的资源进行, 每个有它自己的锁, 常常没
有选择只能获取 2 个锁.

获得多个锁可能是危险的, 然而. 如果你有 2 个锁, 称为 Lock1 和 Lock2, 代码需要同
时都获取, 你有一个潜在的死锁. 仅仅想象一个线程锁住 Lock1 而另一个同时获得
Lock2. 接着每个线程试图得到它没有的那个. 2 个线程都会死锁.

这个问题的解决方法常常是简单的: 当多个锁必须获得时, 它们应当一直以同样顺序获得.
只要遵照这个惯例, 象上面描述的简单死锁能够避免. 然而, 遵照加锁顺序规则是做比说
难. 非常少见这样的规则真正在任何地方被写下. 常常你能做的最好的是看看别的代码如
何做的.

一些经验规则能帮上忙. 如果你必须获得一个对你的代码来说的本地锁(假如, 一个设备
锁), 以及一个属于内核更中心部分的锁, 先获取你的. 如果你有一个旗标和自旋锁的组
合, 你必须, 当然, 先获得旗标; 调用 down (可能睡眠) 在持有一个自旋锁时是一个严
重的错误. 但是最重要的, 尽力避免需要多于一个锁的情况.
