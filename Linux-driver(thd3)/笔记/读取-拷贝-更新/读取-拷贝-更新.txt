读取-拷贝-更新(RCU) 是一个高级的互斥方法, 能够有高效率在合适的情况下. 它在驱动
中的使用很少但是不是没人知道, 因此这里值得快速浏览下. 那些感兴趣 RCU 算法的完
整细节的人可以在由它的创建者出版的白皮书中找到
( http://www.rdrop.com/users/paulmck/rclock/intro/rclock_intro.html).
RCU 对它所保护的数据结构设置了不少限制. 它对经常读而极少写的情况做了优化. 被保
护的资源应当通过指针来存取, 并且所有对这些资源的引用必须由原子代码持有. 当数据
结构需要改变, 写线程做一个拷贝, 改变这个拷贝, 接着使相关的指针对准新的版本 --
因此, 有了算法的名子. 当内核确认没有留下对旧版本的引用, 它可以被释放.
作为在真实世界中使用 RCU 的例子, 考虑一下网络路由表. 每个外出的报文需要请求检
查路由表来决定应当使用哪个接口. 这个检查是快速的, 并且, 一旦内核发现了目标接口,
它不再需要路由表入口项. RCU 允许路由查找在没有锁的情况下进行, 具有相当多的性能
好处. 内核中的 Startmode 无线 IP 驱动也使用 RCU 来跟踪它的设备列表.

使用 RCU 的代码应当包含 <linux/rcupdate.h>.
在读这一边, 使用一个 RCU-保护的数据结构的代码应当用 rcu_read_lock 和
rcu_read_unlock 调用将它的引用包含起来. 结果就是, RCU 代码往往是象这样:
struct my_stuff *stuff;
rcu_read_lock();
stuff = find_the_stuff(args...);
do_something_with(stuff);
rcu_read_unlock();
rcu_read_lock 调用是快的; 它禁止内核抢占但是没有等待任何东西. 在读"锁"被持有时
执行的代码必须是原子的. 在对 rcu_read_unlock 调用后, 没有使用对被保护的资源的
引用.

需要改变被保护的结构的代码必须进行几个步骤. 
第一步是容易的; 它分配一个新结构,
如果需要就从旧的拷贝数据, 接着替换读代码所看到的指针. 在此, 对于读一边的目的,
改变结束了. 任何进入临界区的代码看到数据的新版本.

剩下的是释放旧版本. 当然, 问题是在其他处理器上运行的代码可能仍然有对旧数据的一
个引用, 因此它不能立刻释放. 相反, 写代码必须等待直到它知道没有这样的引用存在了.
因为所有持有对这个数据结构引用的代码必须(规则规定)是原子的, 我们知道一旦系统中
的每个处理器已经被调度了至少一次, 所有的引用必须消失. 这就是 RCU 所做的; 它留
下了一个等待直到所有处理器已经调度的回调; 那个回调接下来被运行来进行清理工作.
改变一个 RCU-保护的数据结构的代码必须通过分配一个 struct rcu_head 来获得它的清
理回调, 尽管不需要以任何方式初始化这个结构. 常常, 那个结构被简单地嵌入在 RCU
所保护的大的资源里面. 在改变资源完成后, 应当调用:

void call_rcu(struct rcu_head *head, void (*func)(void *arg), void *arg);
给定的 func 在释放资源是安全的时候调用; 传递给 call_rcu 的是给同一个 arg. 常常,
func 需要的唯一的东西是调用 kfree.
全部 RCU 接口比我们已见的要更加复杂; 它包括, 例如, 辅助函数来使用被保护的链表.
全部内容见相关的头文件


