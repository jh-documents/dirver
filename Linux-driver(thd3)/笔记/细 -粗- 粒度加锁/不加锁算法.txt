有时, 你可以重新打造你的算法来完全避免加锁的需要. 许多读者/写者情况 -- 如果只
有一个写者 -- 常常能够在这个方式下工作. 如果写者小心使数据结构的视图, 由读者所
见的, 是一直一致的, 有可能创建一个不加锁的数据结构.

常常可以对无锁的生产者/消费者任务有用的数据结构是环形缓存. 这个算法包含一个生
产者安放数据到一个数组的尾端, 而消费者从另一端移走数据. 当到达数组末端, 生产者
绕回到开始. 因此一个环形缓存需要一个数组和 2 个索引值来跟踪下一个新值放到哪里,
以及哪个值在下一次应当从缓存中移走.

当小心地实现了, 一个环形缓存在没有多个生产者或消费者时不需要加锁. 生产者是唯一
允许修改写索引和它所指向的数组位置的线程. 只要写者在更新写索引之前存储一个新值
到缓存中, 读者将一直看到一个一致的视图. 读者, 轮换地, 是唯一存取读索引和它指向
的值的线程. 加一点小心到确保 2 个指针不相互覆盖, 生产者和消费者可以并发存取缓
存而没有竞争情况.

图环形缓冲展示了在几个填充状态的环形缓存. 这个缓存被定义成一个空情况由读写指针
相同来指示, 而满情况发生在写指针紧跟在读指针后面的时候(小心解决绕回!). 当小心
地编程, 这个缓存能够不必加锁地使用.

在设备驱动中环形缓存出现相当多. 网络适配器, 特别地, 常常使用环形缓存来与处理器
交换数据(报文). 注意, 对于 2.6.10, 有一个通用的环形缓存实现在内核中可用; 如何
使用它的信息看 <linux/kfifo.h>.

