第一个支持多处理器系统的 Linux 内核是 2.0; 它只含有一个自旋锁. 这个大内核锁将
整个内核变为一个大的临界区; 在任何时候只有一个 CPU 能够执行内核代码. 这个锁足
够好地解决了并发问题以允许内核开发者从事所有其他的开发 SMP 所包含的问题. 但是
它不是扩充地很好. 甚至一个 2 个处理器的系统可能花费可观数量的时间只是等待这个
大内核锁. 一个 4 个处理器的系统的性能甚至不接近 4 个独立的机器的性能.

因此, 后续的内核发布已经包含了更细粒度的加锁. 在 2.2 中, 一个自旋锁控制对块
I/O 子系统的存取; 另一个为网络而工作, 等等. 一个现代的内核能包含几千个锁, 每个
保护一个小的资源. 这种细粒度的加锁可能对伸缩性是好的; 它允许每个处理器在它自己
特定的任务上工作而不必竞争其他处理器使用的锁. 很少人忘记大内核锁.

但是, 细粒度加锁带有开销. 在有几千个锁的内核中, 很难知道你需要那个锁 -- 以及你
应当以什么顺序获取它们 -- 来进行一个特定的操作. 记住加锁错误可能非常难发现; 更
多的锁提供了更多的机会使真正有害的加锁 bug 钻进内核中. 细粒度加锁能带来一定水
平的复杂性, 长期来, 对内核的可维护性有一个大的, 不利的效果.

在一个设备驱动中加锁常常是相对直接的; 你可以用一个锁来涵盖你做的所有东西, 或者
你可以给你管理的每个设备创建一个锁. 作为一个通用的规则, 你应当从相对粗的加锁开
始, 除非你有确实的理由相信竞争可能是一个问题. 忍住怂恿去过早地优化; 真实地性能
约束常常表现在想不到的地方.

如果你确实怀疑锁竞争在损坏性能, 你可能发现 lockmeter 工具有用. 这个补丁(从
http://oss.sgi.com/projects/lockmeter/ 可得到) 装备内核来测量在锁等待花费的时
间. 通过看这个报告, 你能够很快知道是否锁竞争真的是问题.


加锁的各种选择
Linux 内核提供了不少有力的加锁原语能够用来使内核避免被自己绊倒. 但是, 如同我们
已见到的, 一个加锁机制的设计和实现不是没有缺陷. 常常对于旗标和自旋锁没有选择;
它们可能是唯一的方法来正确地完成工作. 然而, 有些情况, 可以建立原子的存取而不用
完整的加锁. 本节看一下做事情的其他方法.

